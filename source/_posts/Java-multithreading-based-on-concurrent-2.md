---
title: 【Java并发】之多线程基础(2)
date: 2017-10-30 23:19:53
tags:
  - JAVA
  - JAVA并发
categories:
  - JAVA
  - JAVA并发
---

# 进程和线程

进程是指处于运行过程中的程序，并且具有一定的独立性。进程是系统进行资源分配和调度的一个单位。当程序进入内存运行时，即为进程。

## 进程特点

1. 独立性

  进程是系统中独立存在的实体，它可以独立拥有资源，每一个进程都有自己独立的地址空间，没有进程本身的运行，用户进程不可以直接访问其他进程的地址空间。

2. 动态性

  进程和程序的区别在于进程是动态的，进程中有时间的概念，进程具有自己的生命周期和各种不同的状态。

3. 并发性

  多个进程可以在单个处理器上并发执行，互不影响。

<!-- more -->

### 并行和并发区别：

并行：同一时刻可以处理多个任务

并发：统一时刻只能处理1个任务，但在一段时间内可以对多个任务交替处理

图示说明：

{% asset_img concurrent-2-1.png %}

## 线程特点

线程是进程的组成部分，一个进程可以拥有多个线程，而一个线程必须拥有一个父进程。线程可以拥有自己的堆栈，自己的程序计数器和自己的局部变量，但不能拥有系统资源。它与父进程的其他线程共享该进程的所有资源。

线程可以完成一定任务，可以和其它线程共享父进程的共享变量和部分环境，相互协作来完成任务。

线程是独立运行的，其不知道进程中是否还有其他线程存在。

线程的执行是抢占式的，也就是说，当前执行的线程随时可能被挂起，以便运行另一个线程。

一个线程可以创建或撤销另一个线程，一个进程中的多个线程可以并发执行。

# 线程生命周期

当线程被创建并启动以后，它既不是一启动就进入了执行状态，也不是一直处于执行状态。在线程的生命周期中，它要经过``新建(New)``、``就绪（Runnable）``、``运行（Running）``、``阻塞(Blocked)``和``死亡(Dead)``5种状态。尤其是当线程启动以后，它不可能一直"霸占"着CPU独自运行，所以CPU需要在多条线程之间切换，于是线程状态也会多次在运行、阻塞之间切换。

* 新建状态，当程序使用new关键字创建了一个线程之后，该线程就处于新建状态，此时仅由JVM为其分配内存，并初始化其成员变量的值。

* 就绪状态，当线程对象调用了start()方法之后，该线程处于就绪状态。Java虚拟机会为其创建方法调用栈和程序计数器，等待调度运行。

* 运行状态，如果处于就绪状态的线程获得了CPU，开始执行run()方法的线程执行体，则该线程处于运行状态

* 阻塞状态，当处于运行状态的线程失去所占用资源之后，便进入阻塞状态

* 在线程的生命周期当中，线程的各种状态的转换过程

## 新建和就绪状态

当程序使用new关键字创建了一个线程之后，该线程就处于新建状态，此时它和其他的Java对象一样，仅仅由Java虚拟机为其分配内存，并初始化其成员变量的值。此时的线程对象没有表现出任何线程的动态特征，程序也不会执行线程的线程执行体。

当线程对象调用了start()方法之后，该线程处于就绪状态。Java虚拟机会为其创建方法调用栈和程序计数器，处于这个状态中的线程并没有开始运行，只是表示该线程可以运行了。至于该线程何时开始运行，取决于JVM里线程调度器的调度。

调用线程对象的start()方法之后，该线程立即进入就绪状态——就绪状态相当于"等待执行"，但该线程并未真正进入运行状态。如果希望调用子线程的start()方法后子线程立即开始执行，程序可以使用Thread.sleep(1) 来让当前运行的线程（主线程）睡眠1毫秒，1毫秒就够了，因为在这1毫秒内CPU不会空闲，它会去执行另一个处于就绪状态的线程，这样就可以让子线程立即开始执行。

> 注意：启动线程使用start()方法，而不是run()方法。永远不要调用线程对象的run()方法。调用start0方法来启动线程，系统会把该run()方法当成线程执行体来处理；但如果直按调用线程对象的run()方法，则run()方法立即就会被执行，而且在run()方法返回之前其他线程无法并发执行。也就是说，系统把线程对象当成一个普通对象，而run()方法也是一个普通方法，而不是线程执行体。需要指出的是，调用了线程的run()方法之后，该线程已经不再处于新建状态，不要再次调用线程对象的start()方法。只能对处于新建状态的线程调用start()方法，否则将引发IllegaIThreadStateExccption异常。

## 运行和阻塞状态

### 线程调度

如果处于就绪状态的线程获得了CPU，开始执行run()方法的线程执行体，则该线程处于运行状态，如果计算机只有一个CPU。那么在任何时刻只有一个线程处于运行状态，当然在一个多处理器的机器上，将会有多个线程并行执行；当线程数大于处理器数时，依然会存在多个线程在同一个CPU上轮换的现象。

当一个线程开始运行后，它不可能一直处于运行状态（除非它的线程执行体足够短，瞬间就执行结束了）。线程在运行过程中需要被中断，目的是使其他线程获得执行的机会，线程调度的细节取决于底层平台所采用的策略。对于采用抢占式策略的系统而言，系统会给每个可执行的线程一个小时间段来处理任务；当该时间段用完后，系统就会剥夺该线程所占用的资源，让其他线程获得执行的机会。在选择下一个线程时，系统会考虑线程的优先级。

所有现代的桌面和服务器操作系统都采用抢占式调度策略，但一些小型设备如手机则可能采用协作式调度策略，在这样的系统中，只有当一个线程调用了它的sleep()或yield()方法后才会放弃所占用的资源——也就是必须由该线程主动放弃所占用的资源。

### 线程中断

线程中断时一种重要的线程协作机制。线程中断并不会使线程立即退出，而是给线程发送一个通知，告知目标线程，有人希望你退出，至于线程接到通知如何处理，完成是线程自行决定。

JDK中默认提供了强大的支持。

```java
Thread.interrupt(); // 中断线程
Thread.isInterrupted(); // 判断是否被中断
Thread.isTerrupted(); // 判断是否被中断，并清除当前中断状态
```

### 线程阻塞

当发生如下情况时，线程将会进入阻塞状态

1. 线程调用sleep()方法主动放弃所占用的处理器资源

2. 线程调用了一个阻塞式IO方法，在该方法返回之前，该线程被阻塞

3. 线程试图获得一个同步监视器，但该同步监视器正被其他线程所持有。关于同步监视器的知识、后面将存更深入的介绍

4. 线程在等待某个通知（notify）

5. 程序调用了线程的suspend()方法将该线程挂起。但这个方法容易导致死锁，所以应该尽量避免使用该方法

当前正在执行的线程被阻塞之后，其他线程就可以获得执行的机会。被阻塞的线程会在合适的时候重新进入就绪状态，注意是就绪状态而不是运行状态。也就是说，被阻塞线程的阻塞解除后，必须重新等待线程调度器再次调度它。

### 解除阻塞

针对上面几种情况，当发生如下特定的情况时可以解除上面的阻塞，让该线程重新进入就绪状态：

1. 调用sleep()方法的线程经过了指定时间。

2. 线程调用的阻塞式IO方法已经返回。

3. 线程成功地获得了试图取得的同步监视器。

4. 线程正在等待某个通知时，其他线程发出了个通知。

5. 处于挂起状态的线程被调甩了resdme()恢复方法。

线程整个周期状态图如下：

{% asset_img concurrent-2-2.png %}

从图中可以看出，线程从阻塞状态只能进入就绪状态，无法直接进入运行状态。而就绪和运行状态之间的转换通常不受程序控制，而是由系统线程调度所决定。当处于就绪状态的线程获得处理器资源时，该线程进入运行状态；当处于运行状态的线程失去处理器资源时，该线程进入就绪状态。但有一个方法例外，调用yield()方法可以让运行状态的线程转入就绪状态。

## 线程死亡

### 死亡状态

线程会以如下3种方式结束，结束后就处于死亡状态：

1. run()或call()方法执行完成，线程正常结束。

2. 线程抛出一个未捕获的Exception或Error。

3. 直接调用该线程stop()方法来结束该线程——该方法容易导致死锁，通常不推荐使用。常用方式是通过标识方式优雅结束线程。

### 程序设计

当主线程结束时，其他线程不受任何影响，并不会随之结束。一旦子线程启动起来后，它就拥有和主线程相同的地位，它不会受主线程的影响。为了测试某个线程是否已经死亡，可以调用线程对象的isAlivc()方法，当线程处于就绪、运行、阻塞了种状态时，该方法将返回true；当线程处于新建、死亡状态时，该方法将返回false。

> 不要试图对一个已经死亡的线程调用start()方法使它重新启动，死亡就是死亡，该线程将不可再次作为线程执行。



参考资料：
[http://www.cnblogs.com/sunddenly/p/4106562.html](http://www.cnblogs.com/sunddenly/p/4106562.html)
